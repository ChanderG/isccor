
## Background

This is an attempt to understand and teach the common concurrency controls and the levels of isolation they provide in context of Transaction Processing in a semi-practical manner by coding up simulations of them.

In the Database parlance, ACID is the set of properties that the DBMS guarantees of transactions. Among those, the one we are focussed on here is `I', Isolation. Isolation means that transactions do not see each others affects. As such, we want to code simplified versions of the isolation related functionality of Transaction Processors or Managers (hereby referred to as TM throughout).

Also do note that for the purpose of this project, there is a single centralized TM and the data being worked upon is neither sharded nor replicated.

Simply, if the TM were to run all incoming transactions serially, one after another, isolation would be trivially guaranteed. Understandably, that is not performant. Prior effort (a lot of effort) has gone into designing protocols for running transactions concurrently while still somehow providing ACID guarantees. As far as `I` goes, `Serializability` is the formal property that such protocols would have to guarantee.

That is:
```
Theorem 1:
If a concurrency control protcol P is proven to generate schedules that are Serializable, the use of P in a TM guarantees the I of ACID.
```

Some examples of concurrency control protocols that satisfy Theorem 1 are 2PL, TSO, SSI, etc. (Note: we will expand upon and cover some of these acronyms later, no need to worry about specifics now).

Note: At this point, it is good to know that is an even stricter condition called "strict serializability", but we will not go into this now. SS2PL is the above mentioned 2PL extended to enforce this.)

However, in general, applications do not seem to need or demand Serializability. Add to this, the fact that most protocols that satisfy Theorem 1 are not very performant. Hence, a bunch of protocols have come up that do not meet Theorem 1. Instead consider:

```
Theorem 2:
Let a concurrency control protcol P,
P does not satisfy Theorem 1,
The Schedules generated by P, suffer from 1 or more Concurrency anomalies termed as CAs,
P is said to provide Weak Isolation.
```

Concurrency Anomalies are a set of studied anomalies that can occur when multiple transactions are running concurrently. Some or all of them may occur when using a protocol that satisfies Theorem 2. Some may be acceptable for certain clients or applications.

Many protocols satisfying Theorem 2 are in use in the real world in a bunch of different databases and other transaction processing systems. Examples of these include: RU, RC, RR, SI/MVCC, OCC(?) etc.

## What are we doing?

We will model a TM in Erlang and try to implement low-fidelity versions / simulations of a bunch of concurrency control protocols. As a way of testing and contrasting these protocols, we will test them for a bunch of Concurrency Anomalies. In this way, we can understand what each of the protocols bring to the table.

### What are we *NOT* doing?

+ We are not concerned about the performance aspects of any of these protocols. We simply want to see how each protocol handles the different CAs.
+ We are not doing anything realistic. Remember, we are only interested in the 'I' components of 'ACID' and without the other 3, the TMs are not real transaction processors.

## References

1. https://github.com/ept/hermitage
2. http://www.bailis.org/blog/understanding-weak-isolation-is-a-serious-problem/
